r"""
Helper file for auxiliary codes
"""

import numpy as np
from scipy.linalg import block_diag
from pyscf import gto, scf, cc


def spinor_one_and_two_e_int(mol):
    r"""
    Produce one- and two- electron integrals in the spinor basis
    :param mol:
    :param mo_basis:
    :return:
    """
    kin = mol.intor('int1e_kin')
    vnuc = mol.intor('int1e_nuc')
    eri = mol.intor('int2e')
    hcore = kin + vnuc

    spin_hcore = block_diag(hcore, hcore)
    n = hcore.shape[0]
    spin_eri = np.zeros((2*n,2*n,2*n,2*n))
    spin_eri[:n, :n, :n, :n] = eri
    spin_eri[n:, n:, n:, n:] = eri
    spin_eri[:n, :n, n:, n:] = eri
    spin_eri[n:, n:, :n, :n] = eri
    return np.real(spin_hcore), np.real(spin_eri)


def super_matrix_solver(A, B):
    r"""
    Solve RPA like equations
    :return: Eigenvalues, X, and Y matrices
    """
    nA = int(np.sqrt(A.size))
    nB = int(np.sqrt(B.size))
    A = A.reshape((nA, nA))
    B = B.reshape((nB, nB))

    # Construct supermatrix
    supermat = np.zeros((nA+nB, nA+nB))
    supermat[:nA, :nA] = A
    supermat[:nA, nA:] = B
    supermat[nA:, :nA] = -np.conj(B)
    supermat[nA:, nA:] = -np.conj(A)

    # Solve the eigenvalue problem
    e, v = np.linalg.eig(supermat)

    # In our current formulation, A and B are real matrices.
    # Eigenvalues of the supermatrix come in pairs.
    # We take the positive ones (assuming that they mean excitation energies)
    assert np.allclose(np.imag(e), np.zeros(e.shape), rtol=0, atol=1e-8)    # Real eigenvalues
    e = np.real(e)
    positive_idx = np.where(e > 0)[0]
    assert len(positive_idx) == len(e) // 2     # Half of the eigenvalues should be taken

    pos_e = e[positive_idx]
    pos_v = v[:, positive_idx]
    X = pos_v[:nA, :]
    Y = pos_v[nA:, :]
    return pos_e, X, Y

def get_spinorbs(mo:np.ndarray) -> tuple[np.ndarray,np.ndarray]:
    """Gets the core and virtual spin orbitals from a list of molecular orbitals.

    Parameters
    ----------
    mo : np.ndarray
        A list of molecular orbitals generated by PySCF

    Returns
    -------
    tuple[np.ndarray,np.ndarray]
        Core spinorbitals, virtual spin orbitals
    """

    # Core and Virtual Orbitals (spatial orbital basis)
    core_spatialorbs = mo[:, 0].reshape(-1,1)
    vir_spatialorbs = mo[:, 1:]

    # Convert core and virtual orbitals into spin-orbital form. The first half of the columns will be alpha spin orbs, the
    # next half of the columns will be beta spin orbs
    core_spinorbs = block_diag(core_spatialorbs, core_spatialorbs)
    vir_spinorbs = block_diag(vir_spatialorbs, vir_spatialorbs)

    n_occ = core_spinorbs.shape[1]
    n_vir = vir_spinorbs.shape[1]
    print(f"n_occ = {n_occ}, n_vir = {n_vir}")

    return core_spinorbs, vir_spinorbs

def get_self_energy(t2:np.ndarray, oovv:np.ndarray) -> tuple[np.ndarray,np.ndarray]:
    """Calculates the self energy using t2 CC amplitudes. Equ 49 and 50 in the Paper.

    Parameters
    ----------
    t2 : np.ndarray
        t2 amplitudes
    oovv : np.ndarray
        anti symmetrised integral of occupied, occupied, virtual, virtual

    Returns
    -------
    tuple[np.ndarray,np.ndarray]
        occupied self energy, virtual self energy 
    """
    occ_selfeng = 0.5 * np.einsum("ikab,jkab -> ij", oovv,t2,optimize="optimal")
    vir_selfeng = -0.5 * np.einsum("ijbc,ijac -> ab", oovv,t2,optimize="optimal")

    return occ_selfeng, vir_selfeng

def build_fock_matrices(mol:gto.Mole,n_occ:int,n_vir:int)-> tuple[np.ndarray,np.ndarray]:
    """Generates the occupied and virtual fock matricies using PySCF.

    Parameters
    ----------
    mol : gto.Mole
        The molecule to calculate this for.
    n_occ : int
        The number of occupied spin orbitals.
    n_vir : int
        The number of virtual spin orbitals.

    Returns
    -------
    tuple[np.ndarray,np.ndarray]
        The occupied fock matrix, the virtual fock matrix.
    """

    mf = scf.HF(mol)     
    mf.kernel()          
    F_ao = mf.get_fock()    
    C   = mf.mo_coeff        
    F_mo = C.T @ F_ao @ C   
    fock_occ = F_mo[:int(n_occ/2),:int(n_occ/2)]
    fock_vir = F_mo[int(n_occ/2):,int(n_occ/2):]

    #TODO: COME BACK AND GENERALISE TO LARGER SYSTEMS
    spat_occ = int(n_occ/2)
    spat_vir = int(n_vir/2)
    
    fock_occ_spin = np.zeros((n_occ,n_occ))
    fock_vir_spin = np.zeros((n_vir,n_vir))

    fock_occ_spin[:spat_occ,:spat_occ] = fock_occ
    fock_occ_spin[spat_occ:,spat_occ:] = fock_occ

    fock_vir_spin[:spat_vir,:spat_vir] = fock_vir
    fock_vir_spin[spat_vir:,spat_vir:] = fock_vir

    return fock_occ_spin, fock_vir_spin

def build_double_ints(core_spinorbs:np.ndarray,
                      vir_spinorbs:np.ndarray,
                      eri_ao:np.ndarray
                      )-> tuple[np.ndarray,np.ndarray,np.ndarray,np.ndarray,np.ndarray]:
    """Generates either symmetrised or anti-symmetrised double integrals depending on the list of electron repulsion integrals passed as an argument.

    Parameters
    ----------
    core_spinorbs : np.ndarray
        List of core spin orbitals.
    vir_spinorbs : np.ndarray
        List of virtual spin orbitals.
    eri_ao : np.ndarray
        List of electron repulsion integrals.

    Returns
    -------
    tuple[np.ndarray,np.ndarray,np.ndarray,np.ndarray,np.ndarray]
        A tuple containing the different permutation of occupied and virtual orbitals, in this order:
        oovv,ooov,vovv,ovvo,ovov
    """


    # Build the required anti-symmetrised orbitals
    oovv = np.einsum("pi,qj,pqrs,ra,sb->ijab", core_spinorbs, core_spinorbs, eri_ao, vir_spinorbs, vir_spinorbs, optimize="optimal")
    ooov =  np.einsum("pi,qk,pqrs,rj,sc->ikjc",core_spinorbs,core_spinorbs,eri_ao,core_spinorbs,vir_spinorbs,optimize="optimal") 
    vovv =  np.einsum("pa,qk,pqrs,rb,sc->akbc",vir_spinorbs,core_spinorbs,eri_ao,vir_spinorbs,vir_spinorbs,optimize="optimal") 
    ovvo = np.einsum("pi,qa,pqrs,rb,sj->iabj", core_spinorbs, vir_spinorbs, eri_ao, vir_spinorbs, core_spinorbs,optimize="optimal") 
    ovov = np.einsum("pi,qa,pqrs,rj,sb->iajb", core_spinorbs, vir_spinorbs, eri_ao, core_spinorbs, vir_spinorbs, optimize="optimal")

    return oovv,ooov,vovv,ovvo,ovov
