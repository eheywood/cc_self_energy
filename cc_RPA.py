import numpy as np
from pyscf import gto
import BSE_Helper as bse
from scipy.linalg import block_diag

np.set_printoptions(precision=6, suppress=True, linewidth=100000)
eV_to_Hartree = 0.0367493

def get_spinorbs_RPA(mo:np.ndarray, n_occ_spatial, n_vir_spatial) -> tuple[np.ndarray,np.ndarray]:
    """Gets the core and virtual spin orbitals from a list of molecular orbitals.

    Parameters
    ----------
    mo : np.ndarray
        A list of molecular orbitals generated by PySCF

    Returns
    -------
    tuple[np.ndarray,np.ndarray]
        Core spinorbitals, virtual spin orbitals
    """
    print(mo.shape)
    n_occ_spin = n_occ_spatial*2
    n_vir_spin = n_vir_spatial*2

    # Core and Virtual Orbitals (spatial orbital basis)
    core_spatialorbs = mo[:,:n_occ_spatial]
    vir_spatialorbs = mo[:,n_occ_spatial:]

    print(f"core spatial shape: {core_spatialorbs.shape}")
    print(f"vir spatial shape: {vir_spatialorbs.shape}")

    # Convert core and virtual orbitals into spin-orbital form. The first half of the columns will be alpha spin orbs, the
    # next half of the columns will be beta spin orbs
    core_spinorbs = block_diag(core_spatialorbs, core_spatialorbs)
    vir_spinorbs = block_diag(vir_spatialorbs, vir_spatialorbs)

    n_occ = core_spinorbs.shape[1]
    n_vir = vir_spinorbs.shape[1]
    print(f"n_occ = {n_occ}, n_vir = {n_vir}")

    return core_spinorbs, vir_spinorbs

def get_GW_BSE_amps(X_rpa,Y_rpa,eig_rpa,vir_gwe, core_gwe,ooov_anti,vovv_anti,oovv_anti) -> tuple[np.ndarray,np.ndarray,np.ndarray]:
    
    # Build W

    #Build the transfer coefficients
    M_ijm = np.einsum("ikjc,kcm->ijm",ooov_anti,X_rpa+Y_rpa,optimize='optimal')
    M_abm = np.einsum("akbc,kcm->abm",vovv_anti,X_rpa+Y_rpa,optimize='optimal') 
    M_iam = np.einsum("ikac,kcm->iam",oovv_anti,X_rpa+Y_rpa,optimize='optimal') 
    M_jbm = M_iam

    inv_eig = 1/eig_rpa
    W_iajb_correction = -2*(np.einsum("ijm,abm,m -> iajb",M_ijm,M_abm,inv_eig,optimize='optimal'))
    W_ijba_correction = -2*(np.einsum("iam,jbm,m -> ijba",M_iam,M_jbm,inv_eig,optimize='optimal'))

    # Using W, find new X and Y
    gwe_diff = vir_gwe.reshape(-1,1) - core_gwe
    AW = -np.einsum("iabj->iajb",ovvo_anti,optimize='optimal') - W_iajb_correction
    AW += np.einsum("ai,ab,ij-> iajb", gwe_diff, np.identity(n_vir),np.identity(n_occ),optimize='optimal')
    BW = -np.einsum("ijab->iajb",oovv_anti,optimize='optimal') - np.einsum("ijba->iajb",W_ijba_correction,optimize='optimal')

    eigW, XW, YW = bse.super_matrix_solver(AW,BW)
    print("GWE-BSE Complete")

    return eigW, XW, YW

def get_RPA_amps(vir_e, core_e, ovvo_anti, oovv_anti, n_occ,n_vir) -> tuple[np.ndarray,np.ndarray,np.ndarray,np.ndarray,np.ndarray]:
    # construct A and B and use supermatrix solver to get eigenvectors and values
    e_diff = vir_e.reshape(-1,1) - core_e
    A = np.einsum("iabj->iajb", ovvo_anti,optimize='optimal') 
    A += np.einsum("ai,ab,ij-> iajb", e_diff, np.identity(n_vir),np.identity(n_occ),optimize='optimal')

    B = np.einsum("ijab->iajb", oovv_anti,optimize='optimal')

    print(A.shape)
    print(B.shape)

    eig, X, Y = bse.super_matrix_solver(A,B)
    print('RPA COMPLETE')
    return eig, X, Y, A, B


def build_RPA_hamiltonian(vir_e, core_e, ovvo_anti, oovv_anti,n_occ,n_vir,t2) -> tuple[np.ndarray,np.ndarray,np.ndarray,np.ndarray]:
    
    H_rpa = np.zeros((n_occ,n_vir,n_occ,n_vir))
    e_diff = vir_e.reshape(-1,1) - core_e

    term_1 = np.einsum("ai,ab,ij->iajb", e_diff,np.identity(n_vir),np.identity(n_occ),optimize='optimal')
    term_2 = np.einsum("iabj->iajb", ovvo_anti,optimize='optimal')

    term_a = np.einsum("ikbc->ibkc",oovv_anti)
    term_b = np.einsum("jkca->kcja",t2)

    term_3 = np.einsum("ibkc,kcja->ibja",term_a,term_b, optimize='optimal')

    H_rpa = term_1 + term_2 + term_3

    return H_rpa, term_1, term_2, term_3



if __name__ == "__main__":

#     mol = gto.M(atom="H 0.00 0.00 0.00; H 0.00 0.00 2.00",
#             basis='cc-pVTZ',
#             spin=0,
#             symmetry=False,
#             unit="Bohr")


#    mol = gto.M(
#        atom = """C -0.00234503 0.00000000 0.87125063
#                C -1.75847785 0.00000000 -1.34973671
#                O  2.27947397 0.00000000 0.71968028
#                H -0.92904537 0.00000000 2.73929404
#                H -2.97955463 1.66046488 -1.25209463
#                H -2.97955463 -1.66046488 -1.25209463
#                H -0.70043433 0.00000000 -3.11066412""",
#        basis = "aug-cc-pVTZ",  
#        spin = 0,
#        symmetry = False,
#        unit = "Bohr",
#    )
#    
    
    mol = gto.M(
    atom = """N 0.12804615 0.00000000 0.00000000
              H -0.59303935 0.88580079 -1.53425197
              H -0.59303935 -1.77160157 0.00000000
              H -0.59303935 0.88580079 1.53425197""",
    basis = "aug-cc-pVTZ",  
    spin = 0,
    symmetry = False,
    unit="Bohr",
)
#    mol = gto.M(atom="Be 0.00000000 0.00000000 0.00000000",
#    basis='aug-cc-pVTZ',
#    spin=0,
#    symmetry=False,
#    unit="Bohr")
    
    # BCCD MO's and amplitudes. (use in GW BSE)
    # mo,t2,core_e,vir_e = bse.bccd_t2_amps(mol)

    # HF molecular orbitals (use in RPA only)
    myhf = mol.HF.run()
    mo = myhf.mo_coeff

    n_mo = myhf.mo_coeff.shape[1]
    n_occ_spatial = mol.nelec[0]  # Number of occupied orbitals (alpha electrons in RHF)
    n_vir_spatial = n_mo - n_occ_spatial  # Number of unoccupied orbitals

    # Orbital energies
    core_e = np.array(list(myhf.mo_energy[:n_occ_spatial]) + list(myhf.mo_energy[:n_occ_spatial]))
    vir_e = np.array(list(myhf.mo_energy[n_occ_spatial:]) + list(myhf.mo_energy[n_occ_spatial:]))

    print(f'len of core:{len(core_e)}')
    print(f'len of vir:{len(vir_e)}')

    core_spinorbs, vir_spinorbs =  get_spinorbs_RPA(mo, n_occ_spatial, n_vir_spatial)

    n_occ = core_spinorbs.shape[1]
    n_vir = vir_spinorbs.shape[1]

    # Constructing <ij|ab> and <ia|bj>
    _, eri_ao = bse.spinor_one_and_two_e_int(mol)                   # Find eri in spinor form
    eri_ao = np.einsum("pqrs->prqs", eri_ao, optimize="optimal")    # Convert to Physicist's notation
    anti_eri_ao = eri_ao - np.einsum("prqs->prsq", eri_ao, optimize='optimal')

    # Build the required anti-symmetrised orbitals
    oovv_anti,ooov_anti,vovv_anti,ovvo_anti,ovov_anti = bse.build_double_ints(core_spinorbs,vir_spinorbs,anti_eri_ao)

    # Self energies (in eV) (for GW-BSE)
    # core_gwe, vir_gwe = bse.get_self_energy(t2,oovv_anti)
    # core_gwe = np.diag(core_gwe)
    # vir_gwe = np.diag(vir_gwe)

    # Solve RPA equations to get amplitudes
    rpa_eig, X_rpa, Y_rpa, A, B = get_RPA_amps(vir_e,core_e,ovvo_anti,oovv_anti,n_occ,n_vir)

    nA = int(np.sqrt(A.size))
    nB = int(np.sqrt(B.size))
    A = A.reshape((nA, nA))
    B = B.reshape((nB, nB))

    t = Y_rpa@np.linalg.inv(X_rpa)
    t_reshaped = t.reshape((n_occ,n_vir,n_occ,n_vir))
    t_reshaped = np.einsum("jbia->ijba",t_reshaped,optimize='optimal')

    H_rpa,term1,term2,term3 = build_RPA_hamiltonian(vir_e,core_e,ovvo_anti,oovv_anti,n_occ,n_vir,t_reshaped)

    # print("A check")
    # print(np.average(np.absolute((np.sort(A.reshape(n_occ,n_vir,n_occ,n_vir))-np.sort(term1+term2)))))

    # print(B.shape)
    # print(t.shape)
    # print((B@t).shape)

    print(H_rpa.shape)
    # (n_occ,n_vir,n_occ,n_vir,nspincase)
    hrpa_sing = bse.sing_excitation(H_rpa, n_occ_spatial, n_vir_spatial)
    hrpa_trip = bse.trip_excitation(H_rpa, n_occ_spatial, n_vir_spatial)

    singE, v = np.linalg.eig(hrpa_sing)
    tripE, v = np.linalg.eig(hrpa_trip)
    
    H_rpa = H_rpa.reshape((n_occ*n_vir, n_occ*n_vir))
    e, _ = np.linalg.eig(H_rpa)

    H_rpa_mat = A + B@t
    #e_mat, _ = np.linalg.eig(H_rpa_mat)
    diff = np.average(np.absolute(np.sort((H_rpa_mat).reshape(n_occ*n_vir,n_occ*n_vir))-np.sort(H_rpa)))
    
    print(f'Self-consistency check: {diff}')

    print(f"length of single excitation:{len(singE)}")
    print("Single excitation:")
    print(np.real(np.sort(singE)/eV_to_Hartree))
    print("Triplet excitation:")
    print(np.sort(tripE)/eV_to_Hartree)

    with open("results.txt", "a", encoding="utf-8") as f:
        f.write("Acetaldehyde, RPA\n")
        #f.write("Beryllium, RPA\n")
        f.write(f"Singlet exci./eV: {np.sort(np.real(singE))[:10] / eV_to_Hartree}\n")
        f.write(f"Triplet exci./eV: {np.sort(np.real(tripE))[:10] / eV_to_Hartree}\n")
        f.write("\n")


